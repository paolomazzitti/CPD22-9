var documenterSearchIndex = {"docs":
[{"location":"analisi.html#Prestazioni","page":"Analisi delle prestazioni","title":"Prestazioni","text":"","category":"section"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"Durante lo studio definitivo del progetto, sono stati eseguiti dei benchamrk, tramite la macro @btime del package BenchmarkTools, per valutare le prestazioni e osservare i benifici apportati alle varie porzioni di codice. ","category":"page"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"Come sperato, le modifiche introdotte hanno migliorato complessivamente le prestazioni rispetto la versione originale, riducendo il tempo di esecuzione di ogni funzione di cui il progetto è composto e il numero di allocazioni in memoria.","category":"page"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"E' da notare come le funzioni bool2d() e bool3d() siano rispettivamente influenzate da planar_arrangement()e da spatial_arrangement(). I tempi di esecuzione di quest'ultime, infatti, impattono fortemente sulle prestazioni complessive del codice. Le figure di seguito, generate automaticamente dal package ProfileView, mostrano graficamente quanto espresso.","category":"page"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"(Image: Prestazioni di bool2d) (Image: Prestazioni di bool3d)","category":"page"},{"location":"analisi.html#Errori-noti","page":"Analisi delle prestazioni","title":"Errori noti","text":"","category":"section"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"Nell’esempio sottostante (due cubi con spigolo unitario e con una faccia in comune) la funzione Lar.coboundary_1() non funziona correttamente e restituisce un errore sul file interface.jl presente in un altro progetto.","category":"page"},{"location":"analisi.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"import LinearAlgebraicRepresentation as Lar\nimport ViewerGL as GL\nusing Base.Threads, SparseArrays\nn, m, p = 1, 1, 1\nV, (VV, EV, FV, CV) = Lar.cuboidGrid([n, m, p], true)\ncube = V, FV, EV\nassembly = Lar.Struct([\n    Lar.Struct([Lar.t(0, 0, 0), Lar.r(0, 0, 0), cube])\n    Lar.Struct([Lar.t(0, 0, 1), Lar.r(0, 0, 0), cube])\n])\nV, FV = Lar.struct2lar(assembly)\n\nmeshes = []\nfor k = 1:length(FV)\n    color = GL.MayaColors[k%12+1] - (rand(Float64, 4) * 0.1)\n    push!(meshes, GL.GLGrid(V, [FV[k]], color, 0.9))\nend\n\nGL.VIEW(meshes);\nW, (copEV, copFE, copCF), boolmatrix = LARgenerators.bool3d(assembly)","category":"page"},{"location":"conclusione.html#Conclusioni","page":"Conclusione","title":"Conclusioni","text":"","category":"section"},{"location":"conclusione.html","page":"Conclusione","title":"Conclusione","text":"In conclusione, il progetto è stato portato a termine con tutti gli obiettivi che ci siamo posti di raggiungere nella fase preliminare. Infatti, esso è stato corretto a livello di errori e tipi, rifattorizzato per poter rendere più leggibili le funzioni, e parallelizzato. I test sono la prova finale che il progetto viene eseguito in tempi molto più brevi e in modo corretto. ","category":"page"},{"location":"esempiobool2d.html#Esempio-bool2d","page":"Esempio con immagini (2D)","title":"Esempio bool2d","text":"","category":"section"},{"location":"esempiobool2d.html","page":"Esempio con immagini (2D)","title":"Esempio con immagini (2D)","text":"using ViewerGL, SparseArrays, BenchmarkTools\nimport LinearAlgebraicRepresentation as Lar\nGL = ViewerGL\n\nV, (VV, EV, FV) = Lar.cuboidGrid([1, 1], true)\nsquare = V, EV\n\nassembly = Lar.Struct([\n    Lar.Struct([Lar.t(0,0), Lar.r(0), square])\n    Lar.Struct([Lar.t(0,0.1), Lar.r(0.1), square])\n    Lar.Struct([Lar.t(0,0.2), Lar.r(0.2), square])\n    Lar.Struct([Lar.t(0,0.3), Lar.r(0.3), square])\n    Lar.Struct([Lar.t(0,0.4), Lar.r(0.4), square])\n])\n\nV, EV = Lar.struct2lar(assembly)\nGL.VIEW([GL.GLGrid(V, EV, GL.COLORS[1], 1), GL.GLFrame2]);\n\nW, copEV, copFE, boolmatrix = bool2d(assembly)\n\nA = boolmatrix[:, 1]\nB = boolmatrix[:, 2]\nC = boolmatrix[:, 3]\nD = boolmatrix[:, 4]\nE = boolmatrix[:, 5]\n\nAorB = A .| B .| C .| D .| E\nAandB = A .& B .& C .& D .& E\nAxorB = A .⊻ B .⊻ C .⊻ D .⊻ E\n\nunion = Matrix(copFE)' * Int.(AorB)\nintersection = Matrix(copFE)' * Int.(AandB)\nxor = Matrix(copFE)' * AxorB\n\nV = convert(Lar.Points,W')\nEV = Lar.cop2lar(copEV)\nEVor = [ev for (k,ev) in enumerate(EV) if abs(union[k])==1 ]\nEVand = [ev for (k,ev) in enumerate(EV) if abs(intersection[k])==1 ]\nEVxor = [ev for (k,ev) in enumerate(EV) if abs(xor[k])==1 ]\n\nGL.VIEW([ GL.GLGrid(V,EVor, GL.COLORS[1],1), GL.GLFrame2 ]);\nGL.VIEW([ GL.GLGrid(V,EVand, GL.COLORS[1],1), GL.GLFrame2 ]);\nGL.VIEW([ GL.GLGrid(V,EVxor, GL.COLORS[1],1), GL.GLFrame2 ]);\n\nmodel = (V,[VV, EVor])\nGL.VIEW( GL.numbering(.5)( model,GL.COLORS[1],0.1 ) );\n\nmodel = (V,[VV, EVand])\nGL.VIEW( GL.numbering(.5)( model,GL.COLORS[1],0.1 ) );\n\nmodel = (V,[VV, EVxor])\nGL.VIEW( GL.numbering(.5)( model,GL.COLORS[1],0.1 ) );","category":"page"},{"location":"esempiobool2d.html#Immagini-bool2d","page":"Esempio con immagini (2D)","title":"Immagini bool2d","text":"","category":"section"},{"location":"esempiobool2d.html","page":"Esempio con immagini (2D)","title":"Esempio con immagini (2D)","text":"(Image: Risultato 1) (Image: Risultato 2) (Image: Risultato 3) (Image: Risultato 4) (Image: Risultato 5) (Image: Risultato 6) (Image: Risultato 7)","category":"page"},{"location":"esempiobool3d.html#Esempio-bool3d","page":"Esempio con immagini (3D)","title":"Esempio bool3d","text":"","category":"section"},{"location":"esempiobool3d.html","page":"Esempio con immagini (3D)","title":"Esempio con immagini (3D)","text":"using SparseArrays, Base.Threads\nimport ViewerGL as GL\nimport LinearAlgebraicRepresentation as Lar\n\nn, m, p = 1, 1, 1\nV, (VV, EV, FV, CV) = Lar.cuboidGrid([n, m, p], true)\ncube = V, FV, EV\n\nassembly = Lar.Struct([ cube,\n    Lar.t(.3,.4,.25), Lar.r(pi/5,0,0), Lar.r(0,0,pi/12), cube,\n    Lar.t(-.2,.4,-.2), Lar.r(0,pi/5,0), Lar.r(0,pi/12,0), cube\n])\n\nV, FV = Lar.struct2lar(assembly)\n\nmeshes = []\nfor k = 1:length(FV)\n    color = GL.MayaColors[k%12+1] - (rand(Float64, 4) * 0.1)\n    push!(meshes, GL.GLGrid(V, [FV[k]], color, 0.9))\nend\nGL.VIEW(meshes);\n\nW, copEV, copFE, copCF, boolmatrix = bool3d(assembly)\nMatrix(boolmatrix)\n\nA = boolmatrix[:, 2]\nB = boolmatrix[:, 3]\nC = boolmatrix[:, 4]\n\nAorBorC = A .| B .| C\nAandBandC = A .& B .& C\nAxorBxorC = A .⊻ B .⊻ C\nAminBminC = .&(A, .!B, .!C)\n\ndifference = Matrix(copCF)' * Int.(AandBandC)\nxor = Matrix(copCF)' * Int.(AxorBxorC)\nor = Matrix(copCF)' * Int.(AorBorC)\nmin = Matrix(copCF)' * Int.(AminBminC)\n\nV, CVs, FVs, EVs = Lar.pols2tria(W, copEV, copFE, copCF, difference) \nGL.VIEW(GL.GLExplode(V, FVs, 1.01, 1.01, 1.01, 99, 0.5));\nGL.VIEW(GL.GLExplode(V, EVs, 1, 1, 1, 1, 1));\n\nV, CVs, FVs, EVs = Lar.pols2tria(W, copEV, copFE, copCF, xor)\nGL.VIEW(GL.GLExplode(V, FVs, 1.01, 1.01, 1.01, 99, 0.5));\nGL.VIEW(GL.GLExplode(V, EVs, 1, 1, 1, 1, 1));\n\nV, CVs, FVs, EVs = Lar.pols2tria(W, copEV, copFE, copCF, or)\nGL.VIEW(GL.GLExplode(V, FVs, 1.01, 1.01, 1.01, 99, 0.5));\nGL.VIEW(GL.GLExplode(V, EVs, 1, 1, 1, 1, 1));\n\n\nV, CVs, FVs, EVs = Lar.pols2tria(W, copEV, copFE, copCF, min)\nGL.VIEW(GL.GLExplode(V, FVs, 1.01, 1.01, 1.01, 99, 0.5));\nGL.VIEW(GL.GLExplode(V, EVs, 1, 1, 1, 1, 1));","category":"page"},{"location":"esempiobool3d.html#Immagini-bool3d","page":"Esempio con immagini (3D)","title":"Immagini bool3d","text":"","category":"section"},{"location":"esempiobool3d.html","page":"Esempio con immagini (3D)","title":"Esempio con immagini (3D)","text":"(Image: Risultato 1) (Image: Risultato 2) (Image: Risultato 3) (Image: Risultato 4) (Image: Risultato 5) (Image: Risultato 6) (Image: Risultato 7) (Image: Risultato 8) (Image: Risultato 9)","category":"page"},{"location":"intro.html#Panoramica","page":"Introduzione","title":"Panoramica","text":"","category":"section"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Una volta creata la partizione del piano o dello spazio indotta da un insieme di oggetti solidi descritti dal proprio bordo, quali superfici in 3D o spezzate poligonali in 2D (singoli tratti di retta), si ottengono i domini del piano e dello spazio, indotti proprio da quella partizione.","category":"page"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Trattasi degli atomi di un’algebra booleana: questo significa che con qualche calcolo è possibile trasformare ciascuno degli oggetti originali in vettori binari e poter poi svolgere tra di loro tutte le possibili operazioni booleane, complicate o meno che siano (and, or, not, eccetera), e che dunque non avverranno tra oggetti solidi ma tra vettori binari ove l’operazione verrà eseguita termine a termine.","category":"page"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Il lavoro finale del progetto è quello di descrivere, mediante una matrice binaria, come ogni generatore è fatto di atomi.","category":"page"},{"location":"intro.html#Strumenti-utilizzati","page":"Introduzione","title":"Strumenti utilizzati","text":"","category":"section"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Lo studio e lo sviluppo del codice sono condotti con l’ausilio di alcuni strumenti di seguito elencati:","category":"page"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Debugger, integrato con il plugin di Julia per il text editor Visual Studio Code: utilizzato allo scopo di analizzare a tempo di esecuzione, il comportamento del codice con forte riguardo rispetto a come vengono modificati i dati di input durante l’intero flusso;\nProfileView, libreria esterna: utilizzata per graficare lo stack delle chiamate ed individuare l’eventuale presenza di colli di bottiglia;\nBenchmarkTools, libreria esterna: necessaria per eseguire confronti sui tempi di esecuzione delle varie funzioni e dimostrare che le ottimizzazioni applicate hanno portato ad un miglioramento delle prestazioni.","category":"page"},{"location":"intro.html#Obiettivi","page":"Introduzione","title":"Obiettivi","text":"","category":"section"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Sono stati individuati alcuni punti su cui ci si è soffermati al fine di migliorare, ove possibile, il progetto:","category":"page"},{"location":"intro.html","page":"Introduzione","title":"Introduzione","text":"Ottimizzazione delle prestazioni tramite tecniche di parallelizzazione, di calcolo distribuito e altre migliorie con riferimento al libro Julia High-Performance;\nScrittura di una documentazione chiara ed esaustiva per migliorare la leggibilità e la comprensibilità delle funzioni principali individuate utilizzando le docstrings del linguaggio Julia;\nCreazione di file di test al fine di verificare l’integrità e la corretta interoperabilità del codice con le altri parti di cui il progetto è composto.","category":"page"},{"location":"grafo.html#Grafo-delle-dipendenze-originale","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze originale","text":"","category":"section"},{"location":"grafo.html","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze della base di codice oggetto di studio. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome della funzione. Gli archi invece hanno una etichetta numerica consecutiva corrispondente all’ordine delle chiamate dal nodo loro origine. Come mostrato nella figura, la funzione pointInPolygonClassification(), seppur non sia dichiarata direttamente all’interno dei file assegnati al progetto, è usata intensivamente e può essere presa in considerazione per possibili ottimizzazioni.","category":"page"},{"location":"grafo.html#Grafo-per-bool2d","page":"Grafo delle dipendenze","title":"Grafo per bool2d","text":"","category":"section"},{"location":"grafo.html","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"(Image: Grafo delle dipendenze per bool2d)","category":"page"},{"location":"grafo.html#Grafo-per-bool3d","page":"Grafo delle dipendenze","title":"Grafo per bool3d","text":"","category":"section"},{"location":"grafo.html","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"(Image: Grafo delle dipendenze per bool2d)","category":"page"},{"location":"grafo.html#Grafo-delle-dipendenze-definitivo","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze definitivo","text":"","category":"section"},{"location":"grafo.html","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"Per quanto riguarda il grafo delle dipendenze relativamente allo studio definitivo, le dipendenze per Lar Generators (3D) non sono cambiate. È invece diverso il grafo di Lar Generators (2D), perché si è notato che la funzione chainbasis2polygons() non fosse più necessaria.","category":"page"},{"location":"grafo.html","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"(Image: Grafo delle dipendenze per bool2d)","category":"page"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.bool3d","category":"page"},{"location":"docs3d.html#LARgenerators.bool3d","page":"Documentazione (3D)","title":"LARgenerators.bool3d","text":"bool3d(assembly)\n\nArguments\n\nassembly::LinearAlgebraicRepresentation.Struct\n\nReturns\n\nW::Matrix{Float64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\ncopCF::SparseMatrixCSC{Int8, Int64}\nboolmatrix::BitMatrix\n\nUsage\n\nusing LARgenerators, SparseArrays, Base.Threads\nimport LinearAlgebraicRepresentation as Lar\n\nn, m, p = 1, 1, 1\nV, (VV, EV, FV, CV) = Lar.cuboidGrid([n, m, p], true)\ncube = V, FV, EV\n\nassembly = Lar.Struct([ cube,\n    Lar.t(.3,.4,.25), Lar.r(pi/5,0,0), Lar.r(0,0,pi/12), cube,\n    Lar.t(-.2,.4,-.2), Lar.r(0,pi/5,0), Lar.r(0,pi/12,0), cube\n])\n\nW, copEV, copFE, copCF, boolmatrix = LARgenerators.bool3d(assembly)\n\nExplanation\n\nAfter the arrangement, extract all the d-cells from (d-1)-coboundary as isolated polyhedra.\nThen compute a single interior point for each of them.\nThen compare each such point against all input boundaries, in order to compute those which it was interior to. Extend this point membership as 3-cell containment within the relative input solids.\nThe point membership with a boundary consists in the parity count of the intersection points of a vertical ray starting at the test point, with the boundary surface.\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.internalpoints","category":"page"},{"location":"docs3d.html#LARgenerators.internalpoints","page":"Documentazione (3D)","title":"LARgenerators.internalpoints","text":"internalpoints(V, copEV, copFE, copCF)\n\nArguments\n\nV::Matrix{Float64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\ncopCF::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\ninnerpoints::Vector{Any}\n\nExplanation\n\nTransform each 3-cell in a solid\nCompute, for each 3-cell, one internal point\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.chainbasis2solids","category":"page"},{"location":"docs3d.html#LARgenerators.chainbasis2solids","page":"Documentazione (3D)","title":"LARgenerators.chainbasis2solids","text":"chainbasis2solids(copEV, copFE, copCF)\n\nArguments\n\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\ncopCF::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\n(FVs, CF)::Tuple{Vector{Vector{Vector{Int64}}}, Vector{Vector{Int64}}}\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.getinternalpoint","category":"page"},{"location":"docs3d.html#LARgenerators.getinternalpoint","page":"Documentazione (3D)","title":"LARgenerators.getinternalpoint","text":"getinternalpoint(V,EV,FV,Fs, copEV,copFE,z,ptest1,ptest2)\n\nArguments\n\nV::Matrix{Float64}\nEV::Vector{Vector{Int64}}\nFV::Vector{Vector{Int64}}\nFs::Vector{Int64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\nz::Vector{Any}\nptest1::Vector{Int64}\nptest2::Vector{Int64}\n\nReturn\n\nptest1::Vector{Int64} or ptest2::Vector{Int64}\n\nExplanation\n\nFor each test point compute the face planes intersected by vertical ray\nTransform each plane in 2D and look whether the intersection point is internal\nReturn the test point with odd numeber of ray intersections\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.testinternalpoint","category":"page"},{"location":"docs3d.html#LARgenerators.testinternalpoint","page":"Documentazione (3D)","title":"LARgenerators.testinternalpoint","text":"testinternalpoint(V, EV, FV)\n\nArguments\n\nV::Matrix{Float64}\nEV::Vector{Vector{Int64}}\nFV::Vector{Vector{Int64}}\n\nReturn\n\nintersectedfaces::Vector{Int64}\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.settestpoints","category":"page"},{"location":"docs3d.html#LARgenerators.settestpoints","page":"Documentazione (3D)","title":"LARgenerators.settestpoints","text":"settestpoints(V, FV, Fs, copEV, copFE)\n\nArguments\n\nV::Matrix{Float64}\nFV::Vector{Vector{Int64}}\nFs::Vector{Int64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\n(ptest1, ptest2)::Tuple{Vector{Float64}, Vector{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.planemap","category":"page"},{"location":"docs3d.html#LARgenerators.planemap","page":"Documentazione (3D)","title":"LARgenerators.planemap","text":"planemap(V,copEV,copFE,face)(point)\n\nArguments\n\nV::Matrix{Float64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\nface::Int64\n\nExplanation\n\nTranform the 3D face and the 3D point in their homologous 2D, in order to test for containment.\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.rayintersection","category":"page"},{"location":"docs3d.html#LARgenerators.rayintersection","page":"Documentazione (3D)","title":"LARgenerators.rayintersection","text":"rayintersection(point3d::Array{Float64})(V,FV,face::Int)\n\nExplanation\n\nCompute the intersection point of the vertical line through point3d w face. If the face is parallel to z axis return false.\n\nUsage\n\njulia> V,(VV,EV,FV,CV) = Lar.simplex(3,true);\n\njulia> V\n3×4 Array{Float64,2}:\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> FV\n4-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n julia> Lar.rayintersection([.333,.333,0])(V,FV,4)\n 3-element Array{Float64,1}:\n  0.333\n  0.333\n  0.3340000000000001\n\n\n\n\n\n","category":"function"},{"location":"docs3d.html","page":"Documentazione (3D)","title":"Documentazione (3D)","text":"LARgenerators.spaceindex","category":"page"},{"location":"docs3d.html#LARgenerators.spaceindex","page":"Documentazione (3D)","title":"LARgenerators.spaceindex","text":"spaceindex(point3d)(model)\n\nCompute the set of face boxes of possible intersection with a point-ray. Work in 3D, where the ray direction is parallel to the z-axis. Return an array of indices of face.\n\nUsage\n\njulia> V,(VV,EV,FV,CV) = Lar.cuboidGrid([1,1,1],true)\n\njulia> spaceindex([.5,.5,.5])((V,FV))\n3-element Array{Int64,1}:\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"In questa sezione vengono presentate tutte le modifiche effettuate al codice, al fine di migliorare il progetto, elencadole nelle diverse fasi di studio.","category":"page"},{"location":"sviluppo.html#Sviluppo-studio-preliminare","page":"Sviluppo","title":"Sviluppo studio preliminare","text":"","category":"section"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Durante lo studio preliminare, il codice è stato modificato rimuovendo tutte le istruzioni ridondanti o inutili e sono state sistemate molte delle instabilità di tipo emerse utilizzando la macro @code_warntype. Sono stati corretti, inoltre, tutti gli errori riscontrati che non permettevano una corretta esecuzione del codice. Di seguito sono elencate tutte le modifiche effettuate:","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"La funzione cat(), utilizzata ampiamente nel progetto per concatenare due o più array, presenta ora il parametro dims;\nCorretti i tipi delle variabili locali FEs, EVs e FVs nelle funzioni chainbasis2polygons() e chainbasis2solids();\nInizializzata la variabile di ambiente LC_NUMERIC con valore C come suggerito dalla documentazione del package Triangulate.","category":"page"},{"location":"sviluppo.html#Sviluppo-studio-definitivo","page":"Sviluppo","title":"Sviluppo studio definitivo","text":"","category":"section"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Al fine di introdurre migliorie prestazionali, è stata individuata la possibilità di ricorrere all’utilizzo della parallelizzazione multi-thread, applicata con criterio, evitando di limitarsi all’esclusiva applicazione delle notazioni offerte da Julia (si vedano le annotazioni @threads, @inbounds e @inline).","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Si è notato infatti che queste non solo andavano ad offrire risultati inattesi ma alle volte costituivano un vero e proprio blocco rispetto a qualsiasi tentativo di esecuzione del progetto, obbligandoci ad annullare queste modifiche e trovare soluzioni differenti. ","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Per garantire che i vari thread possano avere accesso alle stesse informazioni condivise, ma che queste siano accessibili solo da un thread alla volta (thread safety) sono state modificate tutte le porzioni di codice non sicure. A tal riguardo è stata rimossa la funzione push!(), dove possibile, dichiarando in anticipo la dimensione degli array o appongiandosi ad array ausiliari.","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Sono state parallelizzate funzioni, quali:","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"internalPoints2d() di bool2d;\ngetInternalPoint() di bool3d;\nchainBasis2Solids() di bool3d;","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"E’ stata realizzata inoltre una versione specifica della funzione pointInPolygonClassification() che serve ad identificare se dati dei punti, questi siano interni o esterni ad un poligono. Dalla scelta dei punti nelle funzioni settestpoints() e settestpoints2d(), si è riusciti a semplificare la quantità di casistiche if-else da un numero di 15 ad un numero di 4 in una prima iterazione e poi da 4 a 2 in una seconda iterazione. Si è osservato, infatti, che i codici di spigolo ( c_edge ) effettivamente determinanti nell'algoritmo sono esclusivamente 3 e 15.","category":"page"},{"location":"sviluppo.html#Sviluppo-file-di-test","page":"Sviluppo","title":"Sviluppo file di test","text":"","category":"section"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Durante la fase di sviluppo, sono stati implementati anche dei file di test per verificare che le modifiche apportate al codice non abbiano alterato il funzionamento del progetto. A tal riguardo, si distinguono due tipologie di test: una relativa all'integrità dei tipi (utilizzando la macro @inferred) e una alla correttezza dei valori restituiti dalle principali funzioni.","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"julia> using Pkg\njulia> Pkg.test()","category":"page"},{"location":"sviluppo.html","page":"Sviluppo","title":"Sviluppo","text":"Link ai test: https://github.com/paolomazzitti/CPD22-9/tree/studio-definitivo/test","category":"page"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.bool2d","category":"page"},{"location":"docs2d.html#LARgenerators.bool2d","page":"Documentazione (2D)","title":"LARgenerators.bool2d","text":"bool2d(assembly)\n\nArguments\n\nassembly::LinearAlgebraicRepresentation.Struct\n\nReturn\n\nW::Matrix{Float64}\ncopEV::SparseMatrixCSC{Int8,Int64}\ncopFE::SparseMatrixCSC{Int8,Int64}\nboolmatrix::BitMatrix\n\nUsage\n\nusing SparseArrays, LARgenerators, Base.Threads, SparseArrays, IntervalTrees, LinearAlgebra\nimport LinearAlgebraicRepresentation as Lar\n\nV, (VV, EV, FV) = Lar.cuboidGrid([1, 1], true)\nsquare = V, EV\n\nassembly = Lar.Struct([\n    Lar.Struct([Lar.t(0,0), Lar.r(0), square])\n    Lar.Struct([Lar.t(0,0.1), Lar.r(0.1), square])\n    Lar.Struct([Lar.t(0,0.2), Lar.r(0.2), square])\n    Lar.Struct([Lar.t(0,0.3), Lar.r(0.3), square])\n    Lar.Struct([Lar.t(0,0.4), Lar.r(0.4), square])\n])\n\nW, copEV, copFE, boolmatrix = LARgenerators.bool2d(assembly)\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.testinternalpoint2d","category":"page"},{"location":"docs2d.html#LARgenerators.testinternalpoint2d","page":"Documentazione (2D)","title":"LARgenerators.testinternalpoint2d","text":"testinternalpoint2d(listOfModels)(testpoint)\n\nGiven a point, it returns the list of models containing it.\n\nArguments\n\nlistOfModels::Vector{Any}\ntestpoint::Vector{Float64}\n\nReturn\n\nintersectedFaces: Vector{Int64}\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.internalpoints2d","category":"page"},{"location":"docs2d.html#LARgenerators.internalpoints2d","page":"Documentazione (2D)","title":"LARgenerators.internalpoints2d","text":"internalpoints2d(W, copEV, copFE)\n\nReturns, for each atom of the decomposition, an internal point.\n\nArguments\n\nW::Matrix{Float64}\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\ninternalpoints::Vector{Vector{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.getinternalpoint2d","category":"page"},{"location":"docs2d.html#LARgenerators.getinternalpoint2d","page":"Documentazione (2D)","title":"LARgenerators.getinternalpoint2d","text":"getinternalpoint2d(W, f, copEV, copFE)\n\nReturns an interior point in the polygon. \n\nArguments\n\nW::Matrix{Float64}\nf::Int64\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\nptest1::Vector{Float64} or ptest2::Vector{Float64}\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.settestpoints2d","category":"page"},{"location":"docs2d.html#LARgenerators.settestpoints2d","page":"Documentazione (2D)","title":"LARgenerators.settestpoints2d","text":"settestpoints2d(W, f, copEV, copFE)\n\nGiven a polygon, it returns two points, one inside and one outside it.\n\nArguments\n\nW::Matrix{Float64}\nf::Int64\ncopEV::SparseMatrixCSC{Int8, Int64}\ncopFE::SparseMatrixCSC{Int8, Int64}\n\nReturn\n\n(ptest1, ptest2)::Tuple{Vector{Float64}, Vector{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.pointInPolygonClassificationBool","category":"page"},{"location":"docs2d.html#LARgenerators.pointInPolygonClassificationBool","page":"Documentazione (2D)","title":"LARgenerators.pointInPolygonClassificationBool","text":"pointInPolygonClassificationBool(V, EV)(pnt)\n\nDetermines whether a point is inside or outside a polygon. It is a specific version used for the bool2d function.\n\nArguments\n\nV::Adjoint{Float64, Matrix{Float64}}\nEV::Vector{Vector{Int64}}\npnt::Vector{Float64}\n\nReturn\n\np_in::String or p_out::String\n\n\n\n\n\n","category":"function"},{"location":"docs2d.html","page":"Documentazione (2D)","title":"Documentazione (2D)","text":"LARgenerators.setTileBool","category":"page"},{"location":"docs2d.html#LARgenerators.setTileBool","page":"Documentazione (2D)","title":"LARgenerators.setTileBool","text":"setTileBool(box)(point)\n\nReturns the tile code of an edge.\n\nArguments\n\nbox::Tuple{Float64, Float64, Float64, Float64}\npoint::Vector{Float64}\n\nReturn\n\ntileCodeBool::Int64\n\n\n\n\n\n","category":"function"},{"location":"index.html#Informazioni-generali","page":"Informazioni generali","title":"Informazioni generali","text":"","category":"section"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"Progetto LAR Generators per il corso di Calcolo Parallelo e Distribuito svolto da:","category":"page"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"Nome Matricola E-mail Profilo Github\nPaolo Mazzitti 502042 pao.mazzitti@stud.uniroma3.it https://github.com/paolomazzitti\nMatteo Colonnello 527289 mat.colonnello@stud.uniroma3.it https://github.com/MatteoColonnello\nMartina Falanga 522705 mar.falanga@stud.uniroma3.it https://github.com/MartinaFalanga","category":"page"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"Link al repository GitHub: https://github.com/paolomazzitti/CPD22-9","category":"page"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"Link ai notebook:","category":"page"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"bool2d: https://github.com/paolomazzitti/CPD22-9/blob/studio-definitivo/bool2d.ipynb\nbool3d: https://github.com/paolomazzitti/CPD22-9/blob/studio-definitivo/bool3d.ipynb","category":"page"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"note: Immagini profilo\nLe foto dei componenti del gruppo sono disponibili nei profili personali Github","category":"page"},{"location":"index.html#Indice","page":"Informazioni generali","title":"Indice","text":"","category":"section"},{"location":"index.html","page":"Informazioni generali","title":"Informazioni generali","text":"Pages = [\"intro.md\", \"grafo.md\",\"sviluppo.md\",\"analisi.md\",\"esempiobool2d.md\",\"esempiobool3d.md\",\"conclusioni.md\"]\nDepth = 3","category":"page"}]
}
