var documenterSearchIndex = {"docs":
[{"location":"grafo/#Grafo-delle-dipendenze","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"","category":"section"},{"location":"grafo/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze della base di codice oggetto di studio. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome della funzione. Gli archi invece hanno una etichetta numerica consecutiva corrispondente all’ordine delle chiamate dal nodo loro origine. Come mostrato nella figura, la funzione pointInPolygonClassification(), seppur non sia dichiarata direttamente all’interno dei file assegnati al progetto, è usata intensivamente e può essere presa in considerazione per possibili ottimizzazioni.","category":"page"},{"location":"#Panoramica","page":"Introduzione","title":"Panoramica","text":"","category":"section"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Una volta creata la partizione del piano o dello spazio indotta da un insieme di oggetti solidi descritti dal proprio bordo, quali superfici in 3D o spezzate poligonali in 2D (singoli tratti di retta), si ottengono i domini del piano e dello spazio, indotti proprio da quella partizione.","category":"page"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Trattasi degli atomi di un’algebra booleana: questo significa che con qualche calcolo è possibile trasformare ciascuno degli oggetti originali in vettori binari e poter poi svolgere tra di loro tutte le possibili operazioni booleane, complicate o meno che siano (and, or, not, eccetera), e che dunque non avverranno tra oggetti solidi ma tra vettori binari ove l’operazione verrà eseguita termine a termine.","category":"page"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Il lavoro finale del progetto è quello di descrivere, mediante una matrice binaria, come ogni generatore è fatto di atomi.","category":"page"},{"location":"#Strumenti-utilizzati","page":"Introduzione","title":"Strumenti utilizzati","text":"","category":"section"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Lo studio e lo sviluppo del codice sono condotti con l’ausilio di alcuni strumenti di seguito elencati:","category":"page"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Debugger, integrato con il plugin di Julia per il text editor Visual Studio Code: utilizzato allo scopo di analizzare a tempo di esecuzione, il comportamento del codice con forte riguardo rispetto a come vengono modificati i dati di input durante l’intero flusso;\nProfileView, libreria esterna: utilizzata per graficare lo stack delle chiamate ed individuare l’eventuale presenza di colli di bottiglia;\nBenchmarkTools, libreria esterna: necessaria per eseguire confronti sui tempi di esecuzione delle varie funzioni e dimostrare che le ottimizzazioni applicate hanno portato ad un miglioramento delle prestazioni.","category":"page"},{"location":"#Obiettivi","page":"Introduzione","title":"Obiettivi","text":"","category":"section"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Sono stati individuati alcuni punti su cui ci si è soffermati al fine di migliorare, ove possibile, il progetto:","category":"page"},{"location":"","page":"Introduzione","title":"Introduzione","text":"Ottimizzazione delle prestazioni tramite tecniche di parallelizzazione, di calcolo distribuito e altre migliorie con riferimento al libro Julia High-Performance;\nScrittura di una documentazione chiara ed esaustiva per migliorare la leggibilità e la comprensibilità delle funzioni principali individuate utilizzando le docstrings del linguaggio Julia;\nCreazione di file di test al fine di verificare l’integrità e la corretta interoperabilità del codice con le altri parti di cui il progetto è composto.","category":"page"}]
}
